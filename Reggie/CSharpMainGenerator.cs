using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
namespace Reggie {
    internal partial class CSharpMainGenerator {
        public static void Run(TextWriter Response, IDictionary<string, object> Arguments) {

var w = new Reggie.IndentedTextWriter(Response);
var codenamespace = (string)Arguments["codenamespace"];
var tables = (bool)Arguments["tables"];
var lexer = (bool)Arguments["lexer"];
var outputfile = (string)Arguments["outputfile"];
var inputfile = (string)Arguments["inputfile"];
var input = (TextReader)Arguments["input"];
var codeclass = (string)Arguments["codeclass"];
if(string.IsNullOrEmpty(codeclass)) {
    if(!string.IsNullOrEmpty(outputfile)) {
        codeclass = Path.GetFileNameWithoutExtension(outputfile);
    } else {
        codeclass = Path.GetFileNameWithoutExtension(inputfile);
    }
}
Arguments["codeclass"]=codeclass;
var rules = new List<Reggie.LexRule>();
string line;
while (null != (line = input.ReadLine()))
{
    var lc = LC.LexContext.Create(line);
    lc.TrySkipCCommentsAndWhiteSpace();
    if (-1 != lc.Current)
        rules.Add(Reggie.LexRule.Parse(lc));
}
Reggie.LexRule.FillRuleIds(rules);
Arguments["rules"]=rules;
if(!string.IsNullOrEmpty(codenamespace)) {
            Response.Write("\r\nnamespace ");
            Response.Write(codenamespace);
            Response.Write(" {\r\n    ///<summary>A class generated by ");
            Response.Write(Program.Name);
            Response.Write(" for running ");
            Response.Write(lexer?"regular expressions":"a lexer");
            Response.Write("\r\n    [System.CodeDom.Compiler.GeneratedCodeAttribute(\"");
            Response.Write(Program.Name);
            Response.Write("\", \"");
            Response.Write(Program.Version.ToString());
            Response.Write("\")]\r\n    partial class ");
            Response.Write(codeclass);
            Response.Write(" {\r\n\r\n    ");

	Run("CSharpCommonGenerator",Arguments,Response,2);
            Response.Write("\r\n");

    if(tables) {
        if(lexer) {
            Response.Write("\r\n");

            Run("CSharpTableTokenizerGenerator",Arguments,Response,2);
        } else { // if(lexer) ...
            Response.Write("\r\n");

            Run("CSharpTableMatcherGenerator",Arguments,Response,2);
        } // if(lexer) ...
    } else { // if(tables) ...
        if(lexer) {
            Response.Write("\r\n");

            Run("CSharpCompiledTokenizerGenerator",Arguments,Response,2);
        } else { // if(lexer) ...
            Response.Write("\r\n");

            Run("CSharpCompiledMatcherGenerator",Arguments,Response,2);
        } // if(lexer) ...
    } // if(tables) ... 
            Response.Write("\r\n    }");
 // partial class ...

            Response.Write("\r\n}");
 
} else { // if(!string.IsNullOrEmpty(codenamespace)) ... 
            Response.Write("\r\n///<summary>A class generated by Reggie for running ");
            Response.Write(lexer?"regular expressions":"a lexer");
            Response.Write("\r\n[System.CodeDom.Compiler.GeneratedCodeAttribute(\"");
            Response.Write(Program.Name);
            Response.Write("\", \"");
            Response.Write(Program.Version.ToString());
            Response.Write("\")]\r\npartial class ");
            Response.Write(codeclass);
            Response.Write(" {");

	Run("CSharpCommonGenerator",Arguments,Response,1);
    if(tables) {
        if(lexer) {
            Run("CSharpTableTokenizerGenerator",Arguments,Response,1);
        } else {
            Run("CSharpTableMatcherGenerator",Arguments,Response,1);
        }
    } else { // if(tables) ...
        if(lexer) {
            Run("CSharpCompiledTokenizerGenerator",Arguments,Response,1);
        } else { // if(lexer) ...
            Run("CSharpCompiledMatcherGenerator",Arguments,Response,1);
        } // if(lexer) ...
   } // if(tables) 
            Response.Write("\r\n} ");
// partial class ...
} // if(!string.IsNullOrEmpty(codenamespace)) ...
            Response.Write("\r\n");
            Response.Flush();
        }
    }
}
