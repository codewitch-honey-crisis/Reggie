using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
namespace Test {
    class Program {
        readonly static string[] Tests = new string[] {
            ".... foo /* bar */.. foo...",
            "/****/ foo bar baz /*",
            "foo bar /* baz */ 123 -456.78...",
           "\r\nThe quick brown fox\r\n\tjumped over the\r\n\t\tlazy dog.",
            "        /* a*/ baz  12343 foo    123.22 bar....",
            "/*baz*//*bar*/",
            "...		/* ...a*/.. baz  ... 12343 foo	123.22 bar....", 
            "bar", 
            " \t ", 
            "  /*   */ "
        };
        enum DoDB {
            // don't update the DB
            None = 0,
            // update the DB from the SQL files in the project directory
            Update = 1,
            // only run the DROP commands from the SQL files in the project directory
            Drop = 2
        }
        const DoDB SqlDbAction = DoDB.Update;
        // if /database is specified reggie generates "USE [<codenamespace>]" SQL commands. If not, you better put a db name in the string below
        const string SqlDbConnectionString = "Server=(local);Integrated Security=SSPI";
        static void Main() {
            //Console.WriteLine(Example.IsCommentBlock("/***/"));
            //Console.WriteLine(Example.IsCommentBlock("/***/ "));
            //Console.WriteLine(Example.IsCommentBlock("/*** "));
            //Console.WriteLine(Example.IsCommentBlock("/* "));
            //Console.WriteLine(Example.IsCommentBlock("/*"));
            /*foreach (var test in Tests) {
                Console.WriteLine(test);
                foreach (var token in Example.MatchFloatLiteral(test)) {
                    _WriteFields(token, Console.Out);
                }
                Console.WriteLine();
                break;
            }*/
            /*foreach(var test in Tests) {
                Console.WriteLine(test);
                foreach (var match in Example.MatchCommentBlock(test)) {
                    _WriteFields(match,Console.Out);
                }
            }*/
            //Console.WriteLine(Example.IsCommentBlock("/**/"));
            //Console.WriteLine(Example.IsCommentBlock("/*foo*/"));
            //Console.WriteLine(Example.IsCommentBlock(""));
            //Console.WriteLine(Example.IsCommentBlock("/*foo*/ "));
            //Console.WriteLine(Example.IsCommentBlock(" /*foo*/"));
            //Console.WriteLine(Example.IsCommentBlock("/*foo "));
            //Console.WriteLine(Example.IsCommentBlock("/*"));
            //Console.WriteLine(Example.IsWhitespace("   "));
            //Console.WriteLine(Example.IsWhitespace(" "));
            //Console.WriteLine(Example.IsWhitespace("foo "));
            //Console.WriteLine(Example.IsWhitespace("   foo"));
            //Console.WriteLine(Example.IsWhitespace(""));
            //return;
            RunAll();
            return;
#pragma warning disable CS0162
            foreach (char ch in "        /* a*/ baz  12343 foo    123.22 bar....") {
                Console.Write((int)ch);
                Console.Write(" ");
            }
            Console.WriteLine();
            foreach (var m in CSTableLexerWithLines.Tokenize("        /* a*/ baz  12343 foo    123.22 bar...."))
                _WriteFields(m,Console.Out);
#pragma warning restore CS0162
        }
        static void RunAll() {

            SqlConnection sqlconn = new SqlConnection(SqlDbConnectionString);
            sqlconn.Open();
            SqlCommand cmd; 
            try {
#pragma warning disable CS0162
                if (DoDB.None != SqlDbAction) {
                    var lcount = 0;
                    var fcount = 0;
                    var sb = new StringBuilder();
                    var dir = Path.Combine(Path.GetDirectoryName(Path.GetDirectoryName(Environment.CurrentDirectory)));
                    // the below code isn't robust enough for general purpose use, but will happily execute the SQL
                    // generated by reggie. If you modify those SQL files, this may get confused.
                    foreach (var sqlfile in Directory.GetFiles(dir, "*.sql")) {
                        using (var sr = File.OpenText(sqlfile)) {
                            sb.Clear();
                            string line;
                            int lc = 1;
                            int linNo = 1;
                            while (null != (line = sr.ReadLine())) {
                                var ncline = line;
                                var ci = line.IndexOf("--");
                                if (-1 != ci) ncline = line.Substring(0, ci);
                                if (SqlDbAction == DoDB.Drop) {
                                    var t = ncline.Trim();

                                    if (t.ToLowerInvariant().Contains("drop table #") || !(t.ToLowerInvariant() == "go" || t.StartsWith("use ", StringComparison.InvariantCultureIgnoreCase) || t.StartsWith("drop ", StringComparison.InvariantCultureIgnoreCase))) {
                                        continue;
                                    } else {
                                        Console.WriteLine(line);
                                    }
                                }
                                if (ncline.Trim().ToLowerInvariant() == "go") {
                                    if (sb.ToString().Trim().Length > 0) {
                                        cmd = new SqlCommand(sb.ToString(), sqlconn);
                                        sb.Clear();
                                        linNo = lc;
                                        cmd.CommandType = System.Data.CommandType.Text;
                                        try {
                                            cmd.ExecuteNonQuery();
                                        }
                                        catch (Exception ex) {
                                            Console.WriteLine("On line {0} in {1}", linNo, sqlfile);
                                            Console.WriteLine("Error executing query part: {0}, continuing.", ex.Message);
                                        }
                                        cmd.Dispose();

                                    }

                                } else {
                                    sb.AppendLine(line);
                                    ++lcount;
                                }
                                ++lc;
                            }
                            if (sb.Length > 0) {
                                cmd = new SqlCommand(sb.ToString(), sqlconn);
                                cmd.CommandType = System.Data.CommandType.Text;
                                try {
                                    cmd.ExecuteNonQuery();
                                }
                                catch (Exception ex) {
                                    Console.WriteLine("On line {0} in {1}", linNo, sqlfile);
                                    Console.WriteLine("Error executing query part: {0}, continuing.", ex.Message);
                                }
                                cmd.Dispose();

                            }
                        }
                        ++fcount;

                    }
                    Console.WriteLine("Batched {0} lines of SQL in {1} files.", lcount, fcount);
                    if (SqlDbAction == DoDB.Drop) {

                        Console.WriteLine("All database elements dropped. Exiting.");
                        return;
                    }
                    Console.WriteLine();
                }
#pragma warning restore CS0162
                
                
                var failed =false;

                for (var i = 0; i < Tests.Length; ++i) {
                    if (_RunCSTests(Tests[i]))
                        failed = true;
                }

                if (failed) {
                    Console.WriteLine("The C# reference implementations failed one or more tests, so further tests cannot be run");
                } else {
                    for (var i = 0; i < Tests.Length; ++i) {
                        if (_RunSqlTests(sqlconn, Tests[i]))
                            failed = true;
                    }
                }
                if (!failed) {
                    Console.WriteLine("All tests passed");
                } else {
                    Console.WriteLine("One or more tests failed");
                }
            }
            finally {
                sqlconn.Close();
            }
        }

        static bool _RunSqlTests(SqlConnection sqlconn, string test) {
            var result = false;
            
            var cstoklinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)>(CSTableLexerWithLines.Tokenize(test));
            
            var cstokcompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)>(CSCompiledLexer.Tokenize(test));
            var cstoktable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)>(CSTableLexer.Tokenize(test));

            var csmatchwslinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(CSTableMatcherWithLines.MatchWhitespace(test));
            var csmatchcblinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(CSTableMatcherWithLines.MatchCommentBlock(test));

            var csmatchwstable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(CSTableMatcher.MatchWhitespace(test));
            var csmatchcbtable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(CSTableMatcher.MatchCommentBlock(test));

            var sqltoklinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)>(_SqlExecTokensWithLines(sqlconn, "dbo.SqlTableLexerWithLines_Tokenize", test));
            
            Console.WriteLine("SQL Table vs C# Table Tokenizing (with lines): {0}", test);

            if(_CompareSets("SQL Table", sqltoklinestable, "C# Table", cstoklinestable))
                result = true;

            Console.WriteLine();

            var sqltoktable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)>(_SqlExecTokens(sqlconn, "dbo.SqlTableLexer_Tokenize", test));

            Console.WriteLine("SQL Table vs C# Table Tokenizing (no lines): {0} ", test);

            if(_CompareSets("SQL Table", sqltoktable, "C# Table", cstoktable))
                result = true;

            Console.WriteLine();

            var sqltoklines = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)>(_SqlExecTokensWithLines(sqlconn, "dbo.SqlCompiledLexerWithLines_Tokenize", test));
            
            Console.WriteLine("SQL Compiled vs C# Table Tokenizing (with lines): {0}", test);

            if(_CompareSets("SQL Compiled", sqltoklines, "C# Table", cstoklinestable))
                result = true;

            Console.WriteLine();

            var sqltok = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)>(_SqlExecTokens(sqlconn, "dbo.SqlCompiledLexer_Tokenize", test));

            Console.WriteLine("SQL Compiled vs C# Table Tokenizing (no lines): {0} ", test);

            if(_CompareSets("SQL Compiled", sqltok, "C# Table", cstoktable))
                result = true;

            Console.WriteLine();

            var sqlmatchwslinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(_SqlExecMatchesWithLines(sqlconn, "dbo.SqlTableMatcherWithLines_MatchWhitespace", test));

            Console.WriteLine("SQL Table vs C# Table Matching Whitespace (with lines): \"{0}\"", test);

            if(_CompareSets("SQL Table", sqlmatchwslinestable, "C# Table", csmatchwslinestable))
                result = true;

            var sqlmatchws = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(_SqlExecMatches(sqlconn, "dbo.SqlCompiledMatcher_MatchWhitespace", test));

            Console.WriteLine("SQL Compiled vs C# Table Matching Whitespace (no lines): \"{0}\"", test);

            if(_CompareSets("SQL Table", sqlmatchws, "C# Table", csmatchwstable))
                result = true;

            var sqlmatchcblinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(_SqlExecMatchesWithLines(sqlconn, "dbo.SqlTableMatcherWithLines_MatchCommentBlock", test));

            Console.WriteLine("SQL Table vs C# Table Matching Comment Block (with lines): \"{0}\"", test);

            if(_CompareSets("SQL Table", sqlmatchcblinestable, "C# Table", csmatchcblinestable))
                result = true;

            var sqlmatchcb = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(_SqlExecMatches(sqlconn, "dbo.SqlCompiledMatcher_MatchCommentBlock", test));

            Console.WriteLine("SQL Compiled vs C# Table Matching Comment Block (no lines): \"{0}\"", test);

            if(_CompareSets("SQL Table", sqlmatchcb, "C# Table", csmatchcbtable))
                result = true;

            Console.WriteLine("SQL Compiled Checker vs C# Compiled Tokenizer: {0} ", test);
            foreach (var tok in cstokcompiled) {
                var s = _GetSymbolName(typeof(CSCompiledLexer), _GetSymbolId(tok));
                if (s != null) {
                    if (_TestValue(sqlconn, "SqlCompiledChecker", s, tok.Value))
                        result = true;
                }
            }
            Console.WriteLine();

            Console.WriteLine("SQL Table Checker vs C# Compiled Tokenizer: {0} ", test);
            foreach (var tok in cstokcompiled) {
                var s = _GetSymbolName(typeof(CSCompiledLexer), _GetSymbolId(tok));
                if (s != null) {
                    if (_TestValue(sqlconn, "SqlTableChecker", s, tok.Value))
                        result = true;
                }
            }
            Console.WriteLine();

            return result;
        }
        static bool _RunCSTests(string test) {
            var result = false;

            Console.WriteLine("C# Tokenizing (with lines), Compiled vs Table: {0} ", test);

            var cstoklinescompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)>(CSCompiledLexerWithLines.Tokenize(test));
            var cstoklinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)>(CSTableLexerWithLines.Tokenize(test));
            if(_CompareSets("C# Compiled", cstoklinescompiled, "C# Table", cstoklinestable))
                result = true;

            Console.WriteLine();

            var cstokcompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)>(CSCompiledLexer.Tokenize(test));
            var cstoktable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)>(CSTableLexer.Tokenize(test));

            Console.WriteLine("C# Tokenizing (no lines), Compiled vs Table: {0} ", test);

            if(_CompareSets("C# Compiled", cstokcompiled, "C# Table", cstoktable))
                result = true;

            Console.WriteLine();
            var csmatchwslinescompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(CSCompiledMatcherWithLines.MatchWhitespace(test));
            var csmatchwslinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(CSTableMatcherWithLines.MatchWhitespace(test));

            Console.WriteLine("C# Matching Whitespace (lines), Compiled vs Table: {0} ", test);

            if(_CompareSets("C# Compiled", csmatchwslinescompiled, "C# Table", csmatchwslinestable))
                result = true;

            Console.WriteLine();
            var csmatchcblinescompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(CSCompiledMatcherWithLines.MatchCommentBlock(test));
            var csmatchcblinestable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)>(CSTableMatcherWithLines.MatchCommentBlock(test));

            Console.WriteLine("C# Matching Comment Block (lines), Compiled vs Table: {0} ", test);

            if(_CompareSets("C# Compiled", csmatchcblinescompiled, "C# Table", csmatchcblinestable))
                result = true;

            Console.WriteLine();


            var csmatchwscompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(CSCompiledMatcher.MatchWhitespace(test));
            var csmatchwstable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(CSTableMatcher.MatchWhitespace(test));

            Console.WriteLine("C# Matching Whitespace (no lines), Compiled vs Table: \"{0}\" ", test);

            if(_CompareSets("C# Compiled", csmatchwscompiled, "C# Table", csmatchwstable))
                result = true;

            Console.WriteLine();

            var csmatchcbcompiled = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(CSCompiledMatcher.MatchCommentBlock(test));
            var csmatchcbtable = new List<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)>(CSTableMatcher.MatchCommentBlock(test));

            Console.WriteLine("C# Matching Comment Block (no lines), Compiled vs Table: {0} ", test);

            if(_CompareSets("C# Compiled", csmatchcbcompiled, "C# Table", csmatchcbtable))
                result = true;

            Console.WriteLine();

            Console.WriteLine("C# Compiled Checker vs C# Compiled Tokenizer: {0} ", test);
            foreach (var tok in cstokcompiled) {
                var s = _GetSymbolName(typeof(CSCompiledLexer), _GetSymbolId(tok));
                if (s != null) {
                    if (_TestValue(typeof(CSCompiledChecker), s, tok.Value))
                        result = true;
                }
            }
            Console.WriteLine();

            Console.WriteLine("C# Table Checker vs C# Compiled Tokenizer: {0} ", test);
            foreach (var tok in cstokcompiled) {
                var s = _GetSymbolName(typeof(CSCompiledLexer), _GetSymbolId(tok));
                if (s != null) {
                    if (_TestValue(typeof(CSTableChecker), s, tok.Value))
                        result = true;
                }
            }
            Console.WriteLine();

            return result;
        }

        static bool _CompareSets(string nx, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)> x, 
            string ny, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)> y) {
            var failed = false;
            if (x.Count == 0 || y.Count == 0) {
                Console.WriteLine("Warning: One or more sets has a zero count.");
            }
            if (x.Count != y.Count) {
                Console.WriteLine((x.Count < y.Count ? string.Format("{0} version",nx) : string.Format("{0} version",ny)) + " is missing results");
                Console.WriteLine("{0} version:",nx);
                foreach (var tok in x)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                Console.WriteLine("{0} version: ", ny);
                foreach (var tok in y)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                failed = true;
            } else {
                for (var i = 0; i < x.Count; ++i) {
                    if (x[i] != y[i]) {
                        Console.WriteLine("Inconsistent results on result index {0}", i);
                        Console.WriteLine("{0} version: ",nx);
                        _WriteFields(x[i], Console.Out);
                        Console.WriteLine();
                        Console.WriteLine("{0} version: ",ny);
                        _WriteFields(y[i], Console.Out);
                        Console.WriteLine();
                        failed = true;
                    }
                }
                
            }
            Console.WriteLine();
            return failed;
        }
        static bool _CompareSets(string nx, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)> x,
                string ny, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)> y) {
            var failed = false;
            if (x.Count == 0 || y.Count == 0) {
                Console.WriteLine("Warning: One or more sets has a zero count.");
            }
            if (x.Count != y.Count) {
                Console.WriteLine((x.Count < y.Count ? string.Format("{0} version", nx) : string.Format("{0} version", ny)) + " is missing results");
                Console.WriteLine("{0} version:", nx);
                foreach (var tok in x)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                Console.WriteLine("{0} version: ", ny);
                foreach (var tok in y)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                failed = true;
            } else {
                for (var i = 0; i < x.Count; ++i) {
                    if (x[i] != y[i]) {
                        Console.WriteLine("Inconsistent results on result index {0}", i);
                        Console.WriteLine("{0} version: ", nx);
                        _WriteFields(x[i], Console.Out);
                        Console.WriteLine();
                        Console.WriteLine("{0} version: ", ny);
                        _WriteFields(y[i], Console.Out);
                        Console.WriteLine();
                        failed = true;
                    }
                }
                
            }
            Console.WriteLine();
            return failed;
        }
        static bool _CompareSets(string nx, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)> x, 
            string ny, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)> y) {
            if (x.Count == 0 || y.Count == 0) {
                Console.WriteLine("Warning: One or more sets has a zero count.");
            }
            var failed = false;
            if (x.Count != y.Count) {
                Console.WriteLine((x.Count < y.Count ? string.Format("{0} version", nx) : string.Format("{0} version", ny)) + " is missing results");
                Console.WriteLine("{0} version:", nx);
                foreach (var tok in x)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                Console.WriteLine("{0} version: ", ny);
                foreach (var tok in y)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                failed = true;
            } else {
                for (var i = 0; i < x.Count; ++i) {
                    if (x[i] != y[i]) {
                        Console.WriteLine("Inconsistent results on result index {0}", i);
                        Console.WriteLine("{0} version: ", nx);
                        _WriteFields(x[i], Console.Out);
                        Console.WriteLine();
                        Console.WriteLine("{0} version: ", ny);
                        _WriteFields(y[i], Console.Out);
                        Console.WriteLine();

                        failed = true;
                    }
                }
                
            }
            Console.WriteLine();
            return failed;
        }
        static bool _CompareSets(string nx, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)> x, 
            string ny, IList<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)> y) {
            if (x.Count == 0 || y.Count == 0) {
                Console.WriteLine("Warning: One or more sets has a zero count.");
            }
            var failed = false;
            if (x.Count != y.Count) {
                Console.WriteLine((x.Count < y.Count ? string.Format("{0} version", nx) : string.Format("{0} version", ny)) + " is missing results");
                Console.WriteLine("{0} version:", nx);
                foreach (var tok in x)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                Console.WriteLine("{0} version: ", ny);
                foreach (var tok in y)
                    _WriteFields(tok, Console.Out);
                Console.WriteLine();
                failed = true;
            } else {
                for (var i = 0; i < x.Count; ++i) {
                    if (x[i] != y[i]) {
                        Console.WriteLine("Inconsistent results on result index {0}", i);
                        Console.WriteLine("{0} version: ", nx);
                        _WriteFields(x[i], Console.Out);
                        Console.WriteLine();
                        Console.WriteLine("{0} version: ", ny);
                        _WriteFields(y[i], Console.Out);
                        Console.WriteLine();

                        failed = true;
                    }
                }
                
            }
            Console.WriteLine();
            return failed;
        }
        static bool _TestValue(Type type,string s, string value) {
            var result = false; 
            var ma = type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
            foreach (var m in ma) {
                if (m.Name == "Is" + s) {
                    try {
                        var b = m.Invoke(null, new object[] { value });
                        if (!(bool)b) {
                            Console.WriteLine("Is{0} returned an invalid result for \"{1}=\"", s, value);
                            result = true;
                        }
                    }
                    catch (TargetInvocationException tie) {
                        throw tie.InnerException;
                    }
                }
            }
            return result;
        }
        static bool _TestValue(SqlConnection sqlconn, string dbclass, string s, string value) {
            if ("ERROR" == s) return false;
            var result = false;
            var res = _SqlExecBool( sqlconn, string.Format("dbo.{0}_Is{1}", dbclass, s),value);
            if(!res) {
                Console.WriteLine("Is{0} returned an invalid result for \"{1}=\"", s, value);
                result = true;
            }
            
            return result;
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)> _SqlExecTokensWithLines(SqlConnection sqlconn, string method, string value)
            => _SqlExecTokenizeWithLinesResultSet(sqlconn, method, value);
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)> _SqlExecTokens(SqlConnection sqlconn, string method, string value)
            => _SqlExecTokenizeResultSet(sqlconn, method, value);
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)> _SqlExecMatchesWithLines(SqlConnection sqlconn, string method, string value)
            => _SqlExecMatchWithLinesResultSet(sqlconn, method, value);
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)> _SqlExecMatches(SqlConnection sqlconn, string method, string value)
            => _SqlExecMatchResultSet(sqlconn, method, value);
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)> _SqlExecTokenizeWithLinesResultSet(SqlConnection sqlconn, string method, string value) {
            var cmd = sqlconn.CreateCommand();
            cmd.CommandType = System.Data.CommandType.StoredProcedure;
            cmd.Parameters.Add(new SqlParameter("value", value));
            cmd.CommandText = method;
            SqlDataReader reader;
            try {
                reader = cmd.ExecuteReader();
            }
            catch (Exception ex) {
                Console.WriteLine("Exception trying to execute SQL procedure: {0}", ex.Message);
                yield break;
            }
            foreach (var tok in _EatTokenizeReaderWithLines(reader)) {
                yield return tok;
            }
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)> _SqlExecTokenizeResultSet(SqlConnection sqlconn, string method, string value) {
            var cmd = sqlconn.CreateCommand();
            cmd.CommandType = System.Data.CommandType.StoredProcedure;
            cmd.Parameters.Add(new SqlParameter("value", value));
            cmd.CommandText = method;
            SqlDataReader reader;
            try {
                reader = cmd.ExecuteReader();
            }
            catch (Exception ex) {
                Console.WriteLine("Exception trying to execute SQL procedure: {0}", ex.Message);
                yield break;
            }
            foreach (var tok in _EatTokenizeReader(reader)) {
                yield return tok;
            }
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)> _SqlExecMatchWithLinesResultSet(SqlConnection sqlconn, string method, string value) {
            var cmd = sqlconn.CreateCommand();
            cmd.CommandType = System.Data.CommandType.StoredProcedure;
            cmd.Parameters.Add(new SqlParameter("value", value));
            cmd.CommandText = method;
            SqlDataReader reader;
            try {
                reader = cmd.ExecuteReader();
            }
            catch (Exception ex) {
                Console.WriteLine("Exception trying to execute SQL procedure: {0}", ex.Message);
                yield break;
            }
            foreach (var match in _EatMatchReaderWithLines(reader)) {
                yield return match;
            }
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)> _SqlExecMatchResultSet(SqlConnection sqlconn, string method, string value) {
            var cmd = sqlconn.CreateCommand();
            cmd.CommandType = System.Data.CommandType.StoredProcedure;
            cmd.Parameters.Add(new SqlParameter("value", value));
            cmd.CommandText = method;
            SqlDataReader reader;
            try {
                reader = cmd.ExecuteReader();
            }
            catch (Exception ex) {
                Console.WriteLine("Exception trying to execute SQL procedure: {0}", ex.Message);
                yield break;
            }
            foreach (var match in _EatMatchReader(reader)) {
                yield return match;
            }
        }
        static bool _SqlExecBool(SqlConnection sqlconn, string method, string value) {
            var cmd = sqlconn.CreateCommand();
            cmd.CommandType = System.Data.CommandType.StoredProcedure;
            cmd.Parameters.Add(new SqlParameter("value", value));
            cmd.CommandText = method;
            try {
                var result = cmd.ExecuteNonQuery();
                return result != 0;
            }
            catch (Exception ex) {
                Console.WriteLine("Exception trying to execute SQL procedure: {0}", ex.Message);
            }
            return false;
        }
        
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value)> _EatTokenizeReader(SqlDataReader reader) {
            while (reader.Read())
                yield return (AbsolutePosition: (long)reader[0], AbsoluteLength: (int)reader[1], Position: (long)reader[2], Length: (int)reader[3], SymbolId: (int)reader[4], Value: (string)reader[5]);
            reader.Close();
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value)> _EatMatchReader(SqlDataReader reader) {
            while (reader.Read())
                yield return (AbsolutePosition: (long)reader[0], AbsoluteLength: (int)reader[1], Position: (long)reader[2], Length: (int)reader[3], Value: (string)reader[4]);
            reader.Close();
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column)> _EatMatchReaderWithLines(SqlDataReader reader) {
            while (reader.Read())
                yield return (AbsolutePosition: (long)reader[0], AbsoluteLength: (int)reader[1], Position: (long)reader[2], Length: (int)reader[3], Value: (string)reader[4], Line: (int) reader[5], Column: (int) reader[6]);
            reader.Close();
        }
        static IEnumerable<(long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column)> _EatTokenizeReaderWithLines(SqlDataReader reader) {
            while(reader.Read())
                yield return (AbsolutePosition: (long)reader[0], AbsoluteLength: (int)reader[1], Position: (long)reader[2], Length: (int)reader[3], SymbolId: (int)reader[4], Value: (string)reader[5], Line: (int)reader[6], Column: (int)reader[7]);
            reader.Close();
        }
        static int _GetSymbolId((long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value) value) {
            return value.SymbolId;
        }
        static int _GetSymbolId((long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column) value) {
            return value.SymbolId;
        }
        static string _GetSymbolName(Type @class, int id) {
            var fa = @class.GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
            foreach (var f in fa) {
                if (f.FieldType == typeof(int)) {
                    var o = f.GetValue(null);
                    if (id == (int)o)
                        return f.Name;
                }
            }
            return null;
        }
        static void _WriteFields((long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value) value, TextWriter writer) {
            writer.WriteLine($"AbsolutePosition: {value.AbsolutePosition}, AbsoluteLength: {value.AbsoluteLength}, Position: {value.Position}, Length: {value.Length}, SymbolId: {value.SymbolId}, Value: {value.Value}");
        }
        static void _WriteFields((long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value, int Line, int Column) value, TextWriter writer) {
            writer.WriteLine($"AbsolutePosition: {value.AbsolutePosition}, AbsoluteLength: {value.AbsoluteLength}, Position: {value.Position}, Length: {value.Length}, Value: {value.Value}, Line: {value.Line}, Column: {value.Column}");
        }
        static void _WriteFields((long AbsolutePosition, int AbsoluteLength, long Position, int Length, string Value) value, TextWriter writer) {
            writer.WriteLine($"AbsolutePosition: {value.AbsolutePosition}, AbsoluteLength: {value.AbsoluteLength}, Position: {value.Position}, Length: {value.Length}, Value: {value.Value}");
        }
        static void _WriteFields((long AbsolutePosition, int AbsoluteLength, long Position, int Length, int SymbolId, string Value, int Line, int Column) value, TextWriter writer) {
            writer.WriteLine($"AbsolutePosition: {value.AbsolutePosition}, AbsoluteLength: {value.AbsoluteLength}, Position: {value.Position}, Length: {value.Length}, SymbolId: {value.SymbolId}, Value: {value.Value}, Line: {value.Line}, Column: {value.Column}");
        }
        static void _WriteFields(object value, TextWriter writer) {
            if (null == value) {
                writer.WriteLine("<null>");
            } else {
                var t = value.GetType();
                var tuple = value as ITuple;
                if (tuple != null) {
                    var attr = t.GetCustomAttribute<TupleElementNamesAttribute>(true);
                    if (attr != null) {
                        for (var i = 0; i < tuple.Length; ++i) {
                            Console.Write(attr.TransformNames[i]);
                            Console.Write(": ");
                            Console.Write(tuple[i]);
                            if (i < tuple.Length - 1)
                                Console.Write(", ");
                        }
                    } else {
                        Console.Write("(");
                        for (var i = 0; i < tuple.Length; ++i) {
                            Console.Write(tuple[i]);
                            if (i < tuple.Length - 1)
                                Console.Write(", ");
                        }
                        Console.WriteLine(")");
                    }
                    return;
                }
                var needsComma = false;
                var fa = t.GetFields(BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.GetField);
                for (var i = 0; i < fa.Length; ++i) {
                    var f = fa[i];
                    writer.Write(f.Name);
                    writer.Write(": ");
                    writer.Write(f.GetValue(value));
                    if (i < fa.Length - 1) {
                        writer.Write(", ");
                    }
                    needsComma = true;
                }
                var pa = t.GetProperties(BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.GetProperty);
                for (var i = 0; i < pa.Length; ++i) {
                    if (needsComma) {
                        writer.Write(", ");
                        needsComma = false;
                    }
                    var p = pa[i];
                    writer.Write(p.Name);
                    writer.Write(": ");
                    writer.Write(p.GetValue(value));
                    if (i < pa.Length - 1) {
                        writer.Write(", ");
                    }
                }
                writer.WriteLine();
            }
        }
    }
}
